
AVR_Studio_radio.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001b8  00800100  000008d0  00000964  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000008d0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001a  008002b8  008002b8  00000b1c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000b1c  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000001c0  00000000  00000000  00000b4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000022a8  00000000  00000000  00000d0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000926  00000000  00000000  00002fb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000008d2  00000000  00000000  000038da  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000004d4  00000000  00000000  000041ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000009b8  00000000  00000000  00004680  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001642  00000000  00000000  00005038  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001f8  00000000  00000000  0000667a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 35 00 	jmp	0x6a	; 0x6a <__ctors_end>
   4:	0c 94 03 01 	jmp	0x206	; 0x206 <__vector_1>
   8:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  10:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  14:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  18:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  1c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  20:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  24:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  28:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  2c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  30:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  34:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  38:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  3c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  40:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  44:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  48:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  4c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  50:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  54:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  58:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  5c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  60:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  64:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>

00000068 <__ctors_start>:
  68:	fc 01       	movw	r30, r24

0000006a <__ctors_end>:
  6a:	11 24       	eor	r1, r1
  6c:	1f be       	out	0x3f, r1	; 63
  6e:	cf ef       	ldi	r28, 0xFF	; 255
  70:	d8 e0       	ldi	r29, 0x08	; 8
  72:	de bf       	out	0x3e, r29	; 62
  74:	cd bf       	out	0x3d, r28	; 61

00000076 <__do_copy_data>:
  76:	12 e0       	ldi	r17, 0x02	; 2
  78:	a0 e0       	ldi	r26, 0x00	; 0
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	e0 ed       	ldi	r30, 0xD0	; 208
  7e:	f8 e0       	ldi	r31, 0x08	; 8
  80:	02 c0       	rjmp	.+4      	; 0x86 <__do_copy_data+0x10>
  82:	05 90       	lpm	r0, Z+
  84:	0d 92       	st	X+, r0
  86:	a8 3b       	cpi	r26, 0xB8	; 184
  88:	b1 07       	cpc	r27, r17
  8a:	d9 f7       	brne	.-10     	; 0x82 <__do_copy_data+0xc>

0000008c <__do_clear_bss>:
  8c:	22 e0       	ldi	r18, 0x02	; 2
  8e:	a8 eb       	ldi	r26, 0xB8	; 184
  90:	b2 e0       	ldi	r27, 0x02	; 2
  92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
  94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
  96:	a2 3d       	cpi	r26, 0xD2	; 210
  98:	b2 07       	cpc	r27, r18
  9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>

0000009c <__do_global_ctors>:
  9c:	10 e0       	ldi	r17, 0x00	; 0
  9e:	ca e6       	ldi	r28, 0x6A	; 106
  a0:	d0 e0       	ldi	r29, 0x00	; 0
  a2:	04 c0       	rjmp	.+8      	; 0xac <__do_global_ctors+0x10>
  a4:	22 97       	sbiw	r28, 0x02	; 2
  a6:	fe 01       	movw	r30, r28
  a8:	0e 94 62 04 	call	0x8c4	; 0x8c4 <__tablejump__>
  ac:	c8 36       	cpi	r28, 0x68	; 104
  ae:	d1 07       	cpc	r29, r17
  b0:	c9 f7       	brne	.-14     	; 0xa4 <__do_global_ctors+0x8>
  b2:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <main>
  b6:	0c 94 66 04 	jmp	0x8cc	; 0x8cc <_exit>

000000ba <__bad_interrupt>:
  ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000be <_Z14initInterrupt0v>:
  printString("\r\n");
}

void initInterrupt0(void)
{
  EIMSK |= (1 << INT0);                  /* Enable INT0 */
  be:	e8 9a       	sbi	0x1d, 0	; 29
  EICRA |= (1<< ISC01);         /* trigger when falling */
  c0:	e9 e6       	ldi	r30, 0x69	; 105
  c2:	f0 e0       	ldi	r31, 0x00	; 0
  c4:	80 81       	ld	r24, Z
  c6:	82 60       	ori	r24, 0x02	; 2
  c8:	80 83       	st	Z, r24
  sei();             /* set global interrupt enable bit */
  ca:	78 94       	sei
  cc:	08 95       	ret

000000ce <_Z5setupv>:
void initInterrupt0(void);
void IRQ_reset_and_respond(void);
// Function declerations <<  Function declerations << Function declerations

void setup(void)
{
  ce:	cf 93       	push	r28
  d0:	df 93       	push	r29
  d2:	00 d0       	rcall	.+0      	; 0xd4 <_Z5setupv+0x6>
  d4:	00 d0       	rcall	.+0      	; 0xd6 <_Z5setupv+0x8>
  d6:	00 d0       	rcall	.+0      	; 0xd8 <_Z5setupv+0xa>
  d8:	cd b7       	in	r28, 0x3d	; 61
  da:	de b7       	in	r29, 0x3e	; 62
	/* add setup code here */
  initUSART();
  dc:	0e 94 55 03 	call	0x6aa	; 0x6aa <_Z9initUSARTv>
	printString("Begin startup\r\n");
  e0:	8d e0       	ldi	r24, 0x0D	; 13
  e2:	91 e0       	ldi	r25, 0x01	; 1
  e4:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	//myRadio.init(SPI_CE,SPI_CSN);
	//myRadio = new NRF24L01p;
	//NRF24L01p myRadio;

	// Start radio
	myRadio.begin();
  e8:	8c eb       	ldi	r24, 0xBC	; 188
  ea:	92 e0       	ldi	r25, 0x02	; 2
  ec:	0e 94 0c 02 	call	0x418	; 0x418 <_ZN9NRF24L01p5beginEv>
	
	// Setup data pipes, addresses etc
	//
	// Use default addresses for now _ CHANGE ADDRESSES HERE IN FUTURE
	unsigned char pipesOn [] = {0x03}; // which pipes to turn on for receiving
  f0:	83 e0       	ldi	r24, 0x03	; 3
  f2:	8e 83       	std	Y+6, r24	; 0x06
	//unsigned char fixedPayloadWidth [] = {0x05}; // number of bytes for payload width
	int fixedPayloadWidth = 2; // number of bytes for payload width
	myRadio.setup_data_pipes(pipesOn, fixedPayloadWidth);
  f4:	42 e0       	ldi	r20, 0x02	; 2
  f6:	50 e0       	ldi	r21, 0x00	; 0
  f8:	be 01       	movw	r22, r28
  fa:	6a 5f       	subi	r22, 0xFA	; 250
  fc:	7f 4f       	sbci	r23, 0xFF	; 255
  fe:	8c eb       	ldi	r24, 0xBC	; 188
 100:	92 e0       	ldi	r25, 0x02	; 2
 102:	0e 94 2e 02 	call	0x45c	; 0x45c <_ZN9NRF24L01p16setup_data_pipesEPhi>
	
	//DEBUG - change RX_ADDR_P0 to see if I am reading the right value
	unsigned char tmpArr [] = {0xE7,0xE7,0xE7,0xE7,0xE7};
 106:	85 e0       	ldi	r24, 0x05	; 5
 108:	e3 e0       	ldi	r30, 0x03	; 3
 10a:	f1 e0       	ldi	r31, 0x01	; 1
 10c:	de 01       	movw	r26, r28
 10e:	11 96       	adiw	r26, 0x01	; 1
 110:	01 90       	ld	r0, Z+
 112:	0d 92       	st	X+, r0
 114:	8a 95       	dec	r24
 116:	e1 f7       	brne	.-8      	; 0x110 <_Z5setupv+0x42>
	myRadio.writeRegister(RX_ADDR_P0,tmpArr, 5);
 118:	25 e0       	ldi	r18, 0x05	; 5
 11a:	30 e0       	ldi	r19, 0x00	; 0
 11c:	ae 01       	movw	r20, r28
 11e:	4f 5f       	subi	r20, 0xFF	; 255
 120:	5f 4f       	sbci	r21, 0xFF	; 255
 122:	6a e0       	ldi	r22, 0x0A	; 10
 124:	8c eb       	ldi	r24, 0xBC	; 188
 126:	92 e0       	ldi	r25, 0x02	; 2
 128:	0e 94 0d 02 	call	0x41a	; 0x41a <_ZN9NRF24L01p13writeRegisterEhPhi>
	
	
	// Configure radio to be TX (transmitter) or RX (receiver)
	printString("Configure Radio\r\n");
 12c:	8d e1       	ldi	r24, 0x1D	; 29
 12e:	91 e0       	ldi	r25, 0x01	; 1
 130:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	if (radioMode)
 134:	80 91 01 01 	lds	r24, 0x0101
 138:	90 91 02 01 	lds	r25, 0x0102
 13c:	89 2b       	or	r24, r25
 13e:	29 f0       	breq	.+10     	; 0x14a <_Z5setupv+0x7c>
	{myRadio.rMode();}// Configure radio to be a receiver
 140:	8c eb       	ldi	r24, 0xBC	; 188
 142:	92 e0       	ldi	r25, 0x02	; 2
 144:	0e 94 a3 02 	call	0x546	; 0x546 <_ZN9NRF24L01p5rModeEv>
 148:	04 c0       	rjmp	.+8      	; 0x152 <_Z5setupv+0x84>
	else
	{myRadio.txMode();}// Configure radio to be a receiver
 14a:	8c eb       	ldi	r24, 0xBC	; 188
 14c:	92 e0       	ldi	r25, 0x02	; 2
 14e:	0e 94 9d 02 	call	0x53a	; 0x53a <_ZN9NRF24L01p6txModeEv>

	// Clear any interrupts
	myRadio.clear_interrupts();
 152:	8c eb       	ldi	r24, 0xBC	; 188
 154:	92 e0       	ldi	r25, 0x02	; 2
 156:	0e 94 09 03 	call	0x612	; 0x612 <_ZN9NRF24L01p16clear_interruptsEv>

	
	tmp_state[0] = *myRadio.readRegister(STATUS, 0);
 15a:	40 e0       	ldi	r20, 0x00	; 0
 15c:	50 e0       	ldi	r21, 0x00	; 0
 15e:	67 e0       	ldi	r22, 0x07	; 7
 160:	8c eb       	ldi	r24, 0xBC	; 188
 162:	92 e0       	ldi	r25, 0x02	; 2
 164:	0e 94 4f 02 	call	0x49e	; 0x49e <_ZN9NRF24L01p12readRegisterEhi>
 168:	fc 01       	movw	r30, r24
 16a:	80 81       	ld	r24, Z
 16c:	80 93 b8 02 	sts	0x02B8, r24
	printString("STATUS: ");
 170:	8f e2       	ldi	r24, 0x2F	; 47
 172:	91 e0       	ldi	r25, 0x01	; 1
 174:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	printBinaryByte(tmp_state[0]);
 178:	80 91 b8 02 	lds	r24, 0x02B8
 17c:	0e 94 31 04 	call	0x862	; 0x862 <_Z15printBinaryByteh>
	printString("\r\n");
 180:	80 eb       	ldi	r24, 0xB0	; 176
 182:	91 e0       	ldi	r25, 0x01	; 1
 184:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>

	
	myRadio.setDebugVal(123);
 188:	6b e7       	ldi	r22, 0x7B	; 123
 18a:	70 e0       	ldi	r23, 0x00	; 0
 18c:	8c eb       	ldi	r24, 0xBC	; 188
 18e:	92 e0       	ldi	r25, 0x02	; 2
 190:	0e 94 04 02 	call	0x408	; 0x408 <_ZN9NRF24L01p11setDebugValEi>
	printString("**************************************  debug_val  = ");
 194:	88 e3       	ldi	r24, 0x38	; 56
 196:	91 e0       	ldi	r25, 0x01	; 1
 198:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	printWord(myRadio.getDebugVal());
 19c:	8c eb       	ldi	r24, 0xBC	; 188
 19e:	92 e0       	ldi	r25, 0x02	; 2
 1a0:	0e 94 08 02 	call	0x410	; 0x410 <_ZN9NRF24L01p11getDebugValEv>
 1a4:	0e 94 83 03 	call	0x706	; 0x706 <_Z9printWordj>
	printString("\r\n");
 1a8:	80 eb       	ldi	r24, 0xB0	; 176
 1aa:	91 e0       	ldi	r25, 0x01	; 1
 1ac:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1b0:	ff ef       	ldi	r31, 0xFF	; 255
 1b2:	20 e7       	ldi	r18, 0x70	; 112
 1b4:	82 e0       	ldi	r24, 0x02	; 2
 1b6:	f1 50       	subi	r31, 0x01	; 1
 1b8:	20 40       	sbci	r18, 0x00	; 0
 1ba:	80 40       	sbci	r24, 0x00	; 0
 1bc:	e1 f7       	brne	.-8      	; 0x1b6 <_Z5setupv+0xe8>
 1be:	00 c0       	rjmp	.+0      	; 0x1c0 <_Z5setupv+0xf2>
 1c0:	00 00       	nop
	//  The IRQ is normally high, and active low
	//  The IRQ is triggered at:
	_delay_ms(100); // Make sure all the configuration is completed before attaching the interrupt
	//attachInterrupt(0, IRQ_resolve, FALLING);
  // The nRF24L01p chip should pullup the pin when not interrupting
  initInterrupt0();
 1c2:	0e 94 5f 00 	call	0xbe	; 0xbe <_Z14initInterrupt0v>
  tmp_state[0] = *myRadio.readRegister(CONFIG, 0);
 1c6:	40 e0       	ldi	r20, 0x00	; 0
 1c8:	50 e0       	ldi	r21, 0x00	; 0
 1ca:	60 e0       	ldi	r22, 0x00	; 0
 1cc:	8c eb       	ldi	r24, 0xBC	; 188
 1ce:	92 e0       	ldi	r25, 0x02	; 2
 1d0:	0e 94 4f 02 	call	0x49e	; 0x49e <_ZN9NRF24L01p12readRegisterEhi>
 1d4:	fc 01       	movw	r30, r24
 1d6:	80 81       	ld	r24, Z
 1d8:	80 93 b8 02 	sts	0x02B8, r24
  printString("CONFIG: ");
 1dc:	8e e6       	ldi	r24, 0x6E	; 110
 1de:	91 e0       	ldi	r25, 0x01	; 1
 1e0:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
  printBinaryByte(tmp_state[0]);
 1e4:	80 91 b8 02 	lds	r24, 0x02B8
 1e8:	0e 94 31 04 	call	0x862	; 0x862 <_Z15printBinaryByteh>
  printString("\r\n");
 1ec:	80 eb       	ldi	r24, 0xB0	; 176
 1ee:	91 e0       	ldi	r25, 0x01	; 1
 1f0:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
}
 1f4:	26 96       	adiw	r28, 0x06	; 6
 1f6:	0f b6       	in	r0, 0x3f	; 63
 1f8:	f8 94       	cli
 1fa:	de bf       	out	0x3e, r29	; 62
 1fc:	0f be       	out	0x3f, r0	; 63
 1fe:	cd bf       	out	0x3d, r28	; 61
 200:	df 91       	pop	r29
 202:	cf 91       	pop	r28
 204:	08 95       	ret

00000206 <__vector_1>:

/* IRQ_resolve
Resolve the attachInterrupt function quickly
*/
ISR(INT0_vect)
{
 206:	1f 92       	push	r1
 208:	0f 92       	push	r0
 20a:	0f b6       	in	r0, 0x3f	; 63
 20c:	0f 92       	push	r0
 20e:	11 24       	eor	r1, r1
 210:	8f 93       	push	r24
	// Get the IRQ code from the receiver and assign it to IRQ_state variable
	//unsigned char * p_tmp;
	//printString("IRQ");
	//IRQ_state = * myRadio.readRegister(STATUS,1); // this returns a pointer, so I dereferenced it to the unsigned char for IRQ_state
	IRQ_state = 1;
 212:	81 e0       	ldi	r24, 0x01	; 1
 214:	80 93 bb 02 	sts	0x02BB, r24
}
 218:	8f 91       	pop	r24
 21a:	0f 90       	pop	r0
 21c:	0f be       	out	0x3f, r0	; 63
 21e:	0f 90       	pop	r0
 220:	1f 90       	pop	r1
 222:	18 95       	reti

00000224 <_Z21IRQ_reset_and_respondv>:
Reset the IRQ in the radio STATUS register
Also resolve the condition which triggered the interrupt
*/
void IRQ_reset_and_respond(void)
{
	printString(" ------------------ RESPOND TO IRQ --------------------- \r\n");
 224:	87 e7       	ldi	r24, 0x77	; 119
 226:	91 e0       	ldi	r25, 0x01	; 1
 228:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	printString("STATUS: ");
	printBinaryByte(tmp_status);
	printString("\r\n");
	*/
	
	tmp_state[0] = *myRadio.readRegister(STATUS, 0);
 22c:	40 e0       	ldi	r20, 0x00	; 0
 22e:	50 e0       	ldi	r21, 0x00	; 0
 230:	67 e0       	ldi	r22, 0x07	; 7
 232:	8c eb       	ldi	r24, 0xBC	; 188
 234:	92 e0       	ldi	r25, 0x02	; 2
 236:	0e 94 4f 02 	call	0x49e	; 0x49e <_ZN9NRF24L01p12readRegisterEhi>
 23a:	fc 01       	movw	r30, r24
 23c:	80 81       	ld	r24, Z
 23e:	80 93 b8 02 	sts	0x02B8, r24
	printString("STATUS: ");
 242:	8f e2       	ldi	r24, 0x2F	; 47
 244:	91 e0       	ldi	r25, 0x01	; 1
 246:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	printBinaryByte(tmp_state[0]);
 24a:	80 91 b8 02 	lds	r24, 0x02B8
 24e:	0e 94 31 04 	call	0x862	; 0x862 <_Z15printBinaryByteh>
	printString("\r\n");
 252:	80 eb       	ldi	r24, 0xB0	; 176
 254:	91 e0       	ldi	r25, 0x01	; 1
 256:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	
	if CHECK_BIT(tmp_state[0],0) // TX_FIFO full
 25a:	80 91 b8 02 	lds	r24, 0x02B8
 25e:	80 ff       	sbrs	r24, 0
 260:	04 c0       	rjmp	.+8      	; 0x26a <_Z21IRQ_reset_and_respondv+0x46>
	{
		printString("TX_FIFO Full\r\n");
 262:	83 eb       	ldi	r24, 0xB3	; 179
 264:	91 e0       	ldi	r25, 0x01	; 1
 266:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	}
	if (CHECK_BIT(tmp_state[0],1)|CHECK_BIT(tmp_state[0],2)|CHECK_BIT(tmp_state[0],3)) // TX_FIFO full
 26a:	80 91 b8 02 	lds	r24, 0x02B8
 26e:	82 fb       	bst	r24, 2
 270:	22 27       	eor	r18, r18
 272:	20 f9       	bld	r18, 0
 274:	81 fb       	bst	r24, 1
 276:	99 27       	eor	r25, r25
 278:	90 f9       	bld	r25, 0
 27a:	92 2b       	or	r25, r18
 27c:	11 f4       	brne	.+4      	; 0x282 <_Z21IRQ_reset_and_respondv+0x5e>
 27e:	83 ff       	sbrs	r24, 3
 280:	04 c0       	rjmp	.+8      	; 0x28a <_Z21IRQ_reset_and_respondv+0x66>
	{
		printString("Pipe Number Changed\r\n");
 282:	82 ec       	ldi	r24, 0xC2	; 194
 284:	91 e0       	ldi	r25, 0x01	; 1
 286:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	}
	if CHECK_BIT(tmp_state[0],4) // Maximum number of TX retries interrupt
 28a:	80 91 b8 02 	lds	r24, 0x02B8
 28e:	84 ff       	sbrs	r24, 4
 290:	08 c0       	rjmp	.+16     	; 0x2a2 <_Z21IRQ_reset_and_respondv+0x7e>
	{
		printString("Max TX retries IRQ\r\n");
 292:	88 ed       	ldi	r24, 0xD8	; 216
 294:	91 e0       	ldi	r25, 0x01	; 1
 296:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
		myRadio.flushTX();
 29a:	8c eb       	ldi	r24, 0xBC	; 188
 29c:	92 e0       	ldi	r25, 0x02	; 2
 29e:	0e 94 03 03 	call	0x606	; 0x606 <_ZN9NRF24L01p7flushTXEv>
	}
	if CHECK_BIT(tmp_state[0],5) // Data sent TX FIFO interrupt
 2a2:	80 91 b8 02 	lds	r24, 0x02B8
 2a6:	85 ff       	sbrs	r24, 5
 2a8:	04 c0       	rjmp	.+8      	; 0x2b2 <_Z21IRQ_reset_and_respondv+0x8e>
	{
		printString("Data Sent TX FIFO IRQ\r\n");
 2aa:	8d ee       	ldi	r24, 0xED	; 237
 2ac:	91 e0       	ldi	r25, 0x01	; 1
 2ae:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	}
	if CHECK_BIT(tmp_state[0],6) // Data ready RX FIFO interrupt
 2b2:	80 91 b8 02 	lds	r24, 0x02B8
 2b6:	86 ff       	sbrs	r24, 6
 2b8:	0a c0       	rjmp	.+20     	; 0x2ce <_Z21IRQ_reset_and_respondv+0xaa>
	{
		printString("Data ready RX FIFO IRQ\r\n");
 2ba:	85 e0       	ldi	r24, 0x05	; 5
 2bc:	92 e0       	ldi	r25, 0x02	; 2
 2be:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
		// Read the data from the R_RX_PAYLOAD
		// RX_P_NO bits 3:1 tell what pipe number the payload is available in 000-101: Data Pipe Number, 110: Not Used, 111: RX_FIFO Empty
		// Get bits 3:1 and right shift to get pipe number
		//pipeNumber = (tmp_state[0] & 0xE) >> 1;
		rxDataFLAG = 1; //Set Rx Data FLAG
 2c2:	81 e0       	ldi	r24, 0x01	; 1
 2c4:	90 e0       	ldi	r25, 0x00	; 0
 2c6:	90 93 ba 02 	sts	0x02BA, r25
 2ca:	80 93 b9 02 	sts	0x02B9, r24
	}
	
	//myRadio.clear_interrupts();
	IRQ_state = 0; //reset IRQ_state
 2ce:	10 92 bb 02 	sts	0x02BB, r1
 2d2:	08 95       	ret

000002d4 <main>:
  EIMSK |= (1 << INT0);                  /* Enable INT0 */
  EICRA |= (1<< ISC01);         /* trigger when falling */
  sei();             /* set global interrupt enable bit */
}

int main(void) {
 2d4:	cf 93       	push	r28
 2d6:	df 93       	push	r29
 2d8:	00 d0       	rcall	.+0      	; 0x2da <main+0x6>
 2da:	00 d0       	rcall	.+0      	; 0x2dc <main+0x8>
 2dc:	1f 92       	push	r1
 2de:	cd b7       	in	r28, 0x3d	; 61
 2e0:	de b7       	in	r29, 0x3e	; 62

  // -------- Inits --------- //
  setup();
 2e2:	0e 94 67 00 	call	0xce	; 0xce <_Z5setupv>
		  printString("CONFIG tx: ");
		  printBinaryByte(tmp_state[0]);
		  printString("\r\n");
          // MISO Command byte for return signal value: 0x02
          //unsigned char tmpData [] = {0x02, signalVal}; // Data needs to be the same size as the fixedDataWidth set in setup
		  unsigned char tmpData [] = {0x02, 0x01}; // Data needs to be the same size as the fixedDataWidth set in setup
 2e6:	68 94       	set
 2e8:	ee 24       	eor	r14, r14
 2ea:	e1 f8       	bld	r14, 1
 2ec:	ff 24       	eor	r15, r15
 2ee:	f3 94       	inc	r15
    // Radio is in TX mode
    if (radioMode == 0) 
    {
      // Send data
      printString("Transmit code abc go\r\n");
      unsigned char tmpData [] = {1,2,3,4,26}; // Data needs to be the same size as the fixedDataWidth set in setup
 2f0:	15 e0       	ldi	r17, 0x05	; 5
                 //                  1-query radioSlave for data
    int serialData	  = 0; // Data byte
	
	

    if (IRQ_state == 1)
 2f2:	80 91 bb 02 	lds	r24, 0x02BB
 2f6:	81 30       	cpi	r24, 0x01	; 1
 2f8:	11 f4       	brne	.+4      	; 0x2fe <main+0x2a>
    {
      IRQ_reset_and_respond();
 2fa:	0e 94 12 01 	call	0x224	; 0x224 <_Z21IRQ_reset_and_respondv>
    }
    
    // Radio is in TX mode
    if (radioMode == 0) 
 2fe:	80 91 01 01 	lds	r24, 0x0101
 302:	90 91 02 01 	lds	r25, 0x0102
 306:	89 2b       	or	r24, r25
 308:	01 f5       	brne	.+64     	; 0x34a <main+0x76>
    {
      // Send data
      printString("Transmit code abc go\r\n");
 30a:	8e e1       	ldi	r24, 0x1E	; 30
 30c:	92 e0       	ldi	r25, 0x02	; 2
 30e:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
      unsigned char tmpData [] = {1,2,3,4,26}; // Data needs to be the same size as the fixedDataWidth set in setup
 312:	e8 e0       	ldi	r30, 0x08	; 8
 314:	f1 e0       	ldi	r31, 0x01	; 1
 316:	de 01       	movw	r26, r28
 318:	11 96       	adiw	r26, 0x01	; 1
 31a:	81 2f       	mov	r24, r17
 31c:	01 90       	ld	r0, Z+
 31e:	0d 92       	st	X+, r0
 320:	8a 95       	dec	r24
 322:	e1 f7       	brne	.-8      	; 0x31c <main+0x48>
      myRadio.txData(tmpData, 5); // This is currently sending data to pipe 0 at the default address. Change this once the radio is working
 324:	45 e0       	ldi	r20, 0x05	; 5
 326:	50 e0       	ldi	r21, 0x00	; 0
 328:	be 01       	movw	r22, r28
 32a:	6f 5f       	subi	r22, 0xFF	; 255
 32c:	7f 4f       	sbci	r23, 0xFF	; 255
 32e:	8c eb       	ldi	r24, 0xBC	; 188
 330:	92 e0       	ldi	r25, 0x02	; 2
 332:	0e 94 a9 02 	call	0x552	; 0x552 <_ZN9NRF24L01p6txDataEPhi>
 336:	2f ef       	ldi	r18, 0xFF	; 255
 338:	83 ed       	ldi	r24, 0xD3	; 211
 33a:	90 e3       	ldi	r25, 0x30	; 48
 33c:	21 50       	subi	r18, 0x01	; 1
 33e:	80 40       	sbci	r24, 0x00	; 0
 340:	90 40       	sbci	r25, 0x00	; 0
 342:	e1 f7       	brne	.-8      	; 0x33c <main+0x68>
 344:	00 c0       	rjmp	.+0      	; 0x346 <main+0x72>
 346:	00 00       	nop
 348:	50 c0       	rjmp	.+160    	; 0x3ea <main+0x116>
    }
    // Radio is in RX mode
    // Receive transmission from master
    else
    {
      if (rxDataFLAG == 1)
 34a:	80 91 b9 02 	lds	r24, 0x02B9
 34e:	90 91 ba 02 	lds	r25, 0x02BA
 352:	01 97       	sbiw	r24, 0x01	; 1
 354:	09 f0       	breq	.+2      	; 0x358 <main+0x84>
 356:	49 c0       	rjmp	.+146    	; 0x3ea <main+0x116>
      {
        // Receive data and print
        unsigned char * tmpRxData = myRadio.rData(2);
 358:	62 e0       	ldi	r22, 0x02	; 2
 35a:	70 e0       	ldi	r23, 0x00	; 0
 35c:	8c eb       	ldi	r24, 0xBC	; 188
 35e:	92 e0       	ldi	r25, 0x02	; 2
 360:	0e 94 d5 02 	call	0x5aa	; 0x5aa <_ZN9NRF24L01p5rDataEi>
        serialCommand = *(tmpRxData+0);
 364:	fc 01       	movw	r30, r24
 366:	00 81       	ld	r16, Z
        serialData    = *(tmpRxData+1);
		myRadio.clear_interrupts();
 368:	8c eb       	ldi	r24, 0xBC	; 188
 36a:	92 e0       	ldi	r25, 0x02	; 2
 36c:	0e 94 09 03 	call	0x612	; 0x612 <_ZN9NRF24L01p16clear_interruptsEv>
		printString("serialData: ");
		printBinaryByte(serialData);
		printString("\r\n");
		*/
        // Check Command byte
        if(serialCommand == 0X01) // Read signal and return data to master
 370:	01 30       	cpi	r16, 0x01	; 1
 372:	99 f5       	brne	.+102    	; 0x3da <main+0x106>
        {
          signalVal++; // Dummy signal value for testing
 374:	80 91 00 01 	lds	r24, 0x0100
 378:	8f 5f       	subi	r24, 0xFF	; 255
 37a:	80 93 00 01 	sts	0x0100, r24
          // Turn Master to transmitter
          myRadio.txMode();
 37e:	8c eb       	ldi	r24, 0xBC	; 188
 380:	92 e0       	ldi	r25, 0x02	; 2
 382:	0e 94 9d 02 	call	0x53a	; 0x53a <_ZN9NRF24L01p6txModeEv>
		  tmp_state[0] = *myRadio.readRegister(CONFIG, 0);
 386:	40 e0       	ldi	r20, 0x00	; 0
 388:	50 e0       	ldi	r21, 0x00	; 0
 38a:	60 e0       	ldi	r22, 0x00	; 0
 38c:	8c eb       	ldi	r24, 0xBC	; 188
 38e:	92 e0       	ldi	r25, 0x02	; 2
 390:	0e 94 4f 02 	call	0x49e	; 0x49e <_ZN9NRF24L01p12readRegisterEhi>
 394:	fc 01       	movw	r30, r24
 396:	80 81       	ld	r24, Z
 398:	80 93 b8 02 	sts	0x02B8, r24
		  printString("CONFIG tx: ");
 39c:	85 e3       	ldi	r24, 0x35	; 53
 39e:	92 e0       	ldi	r25, 0x02	; 2
 3a0:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
		  printBinaryByte(tmp_state[0]);
 3a4:	80 91 b8 02 	lds	r24, 0x02B8
 3a8:	0e 94 31 04 	call	0x862	; 0x862 <_Z15printBinaryByteh>
		  printString("\r\n");
 3ac:	80 eb       	ldi	r24, 0xB0	; 176
 3ae:	91 e0       	ldi	r25, 0x01	; 1
 3b0:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
          // MISO Command byte for return signal value: 0x02
          //unsigned char tmpData [] = {0x02, signalVal}; // Data needs to be the same size as the fixedDataWidth set in setup
		  unsigned char tmpData [] = {0x02, 0x01}; // Data needs to be the same size as the fixedDataWidth set in setup
 3b4:	e9 82       	std	Y+1, r14	; 0x01
 3b6:	fa 82       	std	Y+2, r15	; 0x02
          myRadio.txData(tmpData, 2); // This is currently sending data to pipe 0 at the default address. Change this once the radio is working
 3b8:	42 e0       	ldi	r20, 0x02	; 2
 3ba:	50 e0       	ldi	r21, 0x00	; 0
 3bc:	be 01       	movw	r22, r28
 3be:	6f 5f       	subi	r22, 0xFF	; 255
 3c0:	7f 4f       	sbci	r23, 0xFF	; 255
 3c2:	8c eb       	ldi	r24, 0xBC	; 188
 3c4:	92 e0       	ldi	r25, 0x02	; 2
 3c6:	0e 94 a9 02 	call	0x552	; 0x552 <_ZN9NRF24L01p6txDataEPhi>
          //
          // Turn Master to receiver
          myRadio.rMode();
 3ca:	8c eb       	ldi	r24, 0xBC	; 188
 3cc:	92 e0       	ldi	r25, 0x02	; 2
 3ce:	0e 94 a3 02 	call	0x546	; 0x546 <_ZN9NRF24L01p5rModeEv>
		  printString("Data sent, continue\r\n");
 3d2:	81 e4       	ldi	r24, 0x41	; 65
 3d4:	92 e0       	ldi	r25, 0x02	; 2
 3d6:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
          printWord(*(tmpRxData+x));
          printString("\r\n");
        }
        */
        //myRadio.flushRX();
        myRadio.flushRX();
 3da:	8c eb       	ldi	r24, 0xBC	; 188
 3dc:	92 e0       	ldi	r25, 0x02	; 2
 3de:	0e 94 3b 03 	call	0x676	; 0x676 <_ZN9NRF24L01p7flushRXEv>
        rxDataFLAG = 0; // reset rxDataFLAG
 3e2:	10 92 ba 02 	sts	0x02BA, r1
 3e6:	10 92 b9 02 	sts	0x02B9, r1
 3ea:	8f e0       	ldi	r24, 0x0F	; 15
 3ec:	97 e2       	ldi	r25, 0x27	; 39
 3ee:	01 97       	sbiw	r24, 0x01	; 1
 3f0:	f1 f7       	brne	.-4      	; 0x3ee <main+0x11a>
 3f2:	00 c0       	rjmp	.+0      	; 0x3f4 <main+0x120>
 3f4:	00 00       	nop
 3f6:	7d cf       	rjmp	.-262    	; 0x2f2 <main+0x1e>

000003f8 <_GLOBAL__sub_I_myRadio>:
#include "nRF24L01p.h"


//NRF24L01pClass * myRadio;
//NRF24L01p * myRadio;
NRF24L01p myRadio;
 3f8:	8c eb       	ldi	r24, 0xBC	; 188
 3fa:	92 e0       	ldi	r25, 0x02	; 2
 3fc:	0e 94 01 02 	call	0x402	; 0x402 <_ZN9NRF24L01pC1Ev>
 400:	08 95       	ret

00000402 <_ZN9NRF24L01pC1Ev>:
//NRF24L01p::NRF24L01p(int _cepin, int _csnpin)
NRF24L01p::NRF24L01p()
{
	//ce_pin = _cepin;
	//csn_pin = _csnpin;
	initSPImaster();
 402:	0e 94 41 03 	call	0x682	; 0x682 <_Z13initSPImasterv>
 406:	08 95       	ret

00000408 <_ZN9NRF24L01p11setDebugValEi>:
}

void NRF24L01p::setDebugVal(int tmp_debug_val)
{
	debug_val = tmp_debug_val;
 408:	fc 01       	movw	r30, r24
 40a:	75 8b       	std	Z+21, r23	; 0x15
 40c:	64 8b       	std	Z+20, r22	; 0x14
 40e:	08 95       	ret

00000410 <_ZN9NRF24L01p11getDebugValEv>:
}
	
int NRF24L01p::getDebugVal(void)
{
	return debug_val;
}
 410:	fc 01       	movw	r30, r24
 412:	84 89       	ldd	r24, Z+20	; 0x14
 414:	95 89       	ldd	r25, Z+21	; 0x15
 416:	08 95       	ret

00000418 <_ZN9NRF24L01p5beginEv>:
	return byteIn;
}
	

void NRF24L01p::begin(void)
{
 418:	08 95       	ret

0000041a <_ZN9NRF24L01p13writeRegisterEhPhi>:
	writeRegister(RF_SETUP, tmp_val, 1);
}


void NRF24L01p::writeRegister(unsigned char thisRegister, unsigned char thisValue [], int byteNum)
{
 41a:	ef 92       	push	r14
 41c:	ff 92       	push	r15
 41e:	0f 93       	push	r16
 420:	1f 93       	push	r17
 422:	cf 93       	push	r28
 424:	df 93       	push	r29
 426:	7a 01       	movw	r14, r20
 428:	89 01       	movw	r16, r18
	// Must start with CSN pin high, then bring CSN pin low for the transfer
	// Transmit the command byte
	// Bring CSN pin back to high
	thisRegister = 0x20 | thisRegister;
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CNS pin LOW */
 42a:	2a 98       	cbi	0x05, 2	; 5
	
	SPI_tradeByte(thisRegister); // This is the register that is being written to
 42c:	86 2f       	mov	r24, r22
 42e:	80 62       	ori	r24, 0x20	; 32
 430:	0e 94 50 03 	call	0x6a0	; 0x6a0 <_Z13SPI_tradeByteh>
	int ind=0;
	while (ind < byteNum)
 434:	10 16       	cp	r1, r16
 436:	11 06       	cpc	r1, r17
 438:	4c f4       	brge	.+18     	; 0x44c <_ZN9NRF24L01p13writeRegisterEhPhi+0x32>
 43a:	e7 01       	movw	r28, r14
 43c:	0e 0d       	add	r16, r14
 43e:	1f 1d       	adc	r17, r15
	{
		SPI_tradeByte(thisValue[ind]);
 440:	89 91       	ld	r24, Y+
 442:	0e 94 50 03 	call	0x6a0	; 0x6a0 <_Z13SPI_tradeByteh>
	thisRegister = 0x20 | thisRegister;
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CNS pin LOW */
	
	SPI_tradeByte(thisRegister); // This is the register that is being written to
	int ind=0;
	while (ind < byteNum)
 446:	c0 17       	cp	r28, r16
 448:	d1 07       	cpc	r29, r17
 44a:	d1 f7       	brne	.-12     	; 0x440 <_ZN9NRF24L01p13writeRegisterEhPhi+0x26>
		SPI_tradeByte(thisValue[ind]);
		ind = ind+1;
	}
	
	//digitalWrite(csn_pin, HIGH);
	SPI_CSN_PORT |= (1 << SPI_CSN);                       /* Write CSN pin HIGH */
 44c:	2a 9a       	sbi	0x05, 2	; 5
}
 44e:	df 91       	pop	r29
 450:	cf 91       	pop	r28
 452:	1f 91       	pop	r17
 454:	0f 91       	pop	r16
 456:	ff 90       	pop	r15
 458:	ef 90       	pop	r14
 45a:	08 95       	ret

0000045c <_ZN9NRF24L01p16setup_data_pipesEPhi>:
	//SPI.setClockDivider(SPI_CLOCK_DIV8);

}

void NRF24L01p::setup_data_pipes(unsigned char pipesOn [], const int fixedPayloadWidth)
{
 45c:	ff 92       	push	r15
 45e:	0f 93       	push	r16
 460:	1f 93       	push	r17
 462:	cf 93       	push	r28
 464:	df 93       	push	r29
 466:	1f 92       	push	r1
 468:	cd b7       	in	r28, 0x3d	; 61
 46a:	de b7       	in	r29, 0x3e	; 62
 46c:	8c 01       	movw	r16, r24
 46e:	f4 2e       	mov	r15, r20
	writeRegister(EN_RXADDR, pipesOn, 1);
 470:	21 e0       	ldi	r18, 0x01	; 1
 472:	30 e0       	ldi	r19, 0x00	; 0
 474:	ab 01       	movw	r20, r22
 476:	62 e0       	ldi	r22, 0x02	; 2
 478:	0e 94 0d 02 	call	0x41a	; 0x41a <_ZN9NRF24L01p13writeRegisterEhPhi>
	unsigned char widthArg [] = {(unsigned char)fixedPayloadWidth};
 47c:	f9 82       	std	Y+1, r15	; 0x01
	writeRegister(RX_PW_P0, widthArg, 1);
 47e:	21 e0       	ldi	r18, 0x01	; 1
 480:	30 e0       	ldi	r19, 0x00	; 0
 482:	ae 01       	movw	r20, r28
 484:	4f 5f       	subi	r20, 0xFF	; 255
 486:	5f 4f       	sbci	r21, 0xFF	; 255
 488:	61 e1       	ldi	r22, 0x11	; 17
 48a:	c8 01       	movw	r24, r16
 48c:	0e 94 0d 02 	call	0x41a	; 0x41a <_ZN9NRF24L01p13writeRegisterEhPhi>
}
 490:	0f 90       	pop	r0
 492:	df 91       	pop	r29
 494:	cf 91       	pop	r28
 496:	1f 91       	pop	r17
 498:	0f 91       	pop	r16
 49a:	ff 90       	pop	r15
 49c:	08 95       	ret

0000049e <_ZN9NRF24L01p12readRegisterEhi>:




unsigned char * NRF24L01p::readRegister(unsigned char thisRegister, int byteNum)
{
 49e:	cf 92       	push	r12
 4a0:	df 92       	push	r13
 4a2:	ef 92       	push	r14
 4a4:	ff 92       	push	r15
 4a6:	0f 93       	push	r16
 4a8:	1f 93       	push	r17
 4aa:	cf 93       	push	r28
 4ac:	df 93       	push	r29
 4ae:	6c 01       	movw	r12, r24
 4b0:	86 2f       	mov	r24, r22
 4b2:	7a 01       	movw	r14, r20
	// Must start with CSN pin high, then bring CSN pin low for the transfer
	// Transmit the command byte and the same number of dummy bytes as expected to receive from the register
	// Read the same number of bytes from radio plus the STATUS register as the first byte returned
	// Bring CSN pin back to high
	//digitalWrite(csn_pin, LOW);
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CSN pin LOW */
 4b4:	2a 98       	cbi	0x05, 2	; 5
	
	SPI_tradeByte(thisRegister); // This is the register that is being read from
 4b6:	0e 94 50 03 	call	0x6a0	; 0x6a0 <_Z13SPI_tradeByteh>
	int ind = 0;
	
	while (ind <= byteNum)
 4ba:	ff 20       	and	r15, r15
 4bc:	84 f0       	brlt	.+32     	; 0x4de <_ZN9NRF24L01p12readRegisterEhi+0x40>
 4be:	86 01       	movw	r16, r12
 4c0:	02 5f       	subi	r16, 0xF2	; 242
 4c2:	1f 4f       	sbci	r17, 0xFF	; 255
	// Bring CSN pin back to high
	//digitalWrite(csn_pin, LOW);
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CSN pin LOW */
	
	SPI_tradeByte(thisRegister); // This is the register that is being read from
	int ind = 0;
 4c4:	c0 e0       	ldi	r28, 0x00	; 0
 4c6:	d0 e0       	ldi	r29, 0x00	; 0
	
	while (ind <= byteNum)
	{
		SPI_tradeByte(0x00); // First byte returned is the status, subsequent bytes are from register
 4c8:	80 e0       	ldi	r24, 0x00	; 0
 4ca:	0e 94 50 03 	call	0x6a0	; 0x6a0 <_Z13SPI_tradeByteh>
		register_value[ind] = SPDR; 
 4ce:	8e b5       	in	r24, 0x2e	; 46
 4d0:	f8 01       	movw	r30, r16
 4d2:	81 93       	st	Z+, r24
 4d4:	8f 01       	movw	r16, r30
		//register_value[ind] = SPI_tradeByte(0x00); // First byte returned is the status, subsequent bytes are from register
		//Serial.print("Register byte ");
		//Serial.print(ind);
		//Serial.print(" value = ");
		//Serial.println(register_value[ind], BIN);
		ind = ind+1;
 4d6:	21 96       	adiw	r28, 0x01	; 1
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CSN pin LOW */
	
	SPI_tradeByte(thisRegister); // This is the register that is being read from
	int ind = 0;
	
	while (ind <= byteNum)
 4d8:	ec 16       	cp	r14, r28
 4da:	fd 06       	cpc	r15, r29
 4dc:	ac f7       	brge	.-22     	; 0x4c8 <_ZN9NRF24L01p12readRegisterEhi+0x2a>
		//Serial.println(register_value[ind], BIN);
		ind = ind+1;
	}
	
	//digitalWrite(csn_pin, HIGH);
	SPI_CSN_PORT |= (1 << SPI_CSN);                       /* Write CSN pin HIGH */
 4de:	2a 9a       	sbi	0x05, 2	; 5
	
	return register_value;
	
}
 4e0:	c6 01       	movw	r24, r12
 4e2:	0e 96       	adiw	r24, 0x0e	; 14
 4e4:	df 91       	pop	r29
 4e6:	cf 91       	pop	r28
 4e8:	1f 91       	pop	r17
 4ea:	0f 91       	pop	r16
 4ec:	ff 90       	pop	r15
 4ee:	ef 90       	pop	r14
 4f0:	df 90       	pop	r13
 4f2:	cf 90       	pop	r12
 4f4:	08 95       	ret

000004f6 <_ZN9NRF24L01p11configRadioEbb>:
Configure the NRF24L01p and startup
@param RXTX sets the radio into 1:Receive 0:Transmit
@param PWRUP_PWRDOWN 1:Power Up 0:Power Down
*/
void NRF24L01p::configRadio(bool RXTX, bool PWRUP_PWRDOWN)
{
 4f6:	cf 93       	push	r28
 4f8:	df 93       	push	r29
 4fa:	00 d0       	rcall	.+0      	; 0x4fc <_ZN9NRF24L01p11configRadioEbb+0x6>
 4fc:	00 d0       	rcall	.+0      	; 0x4fe <_ZN9NRF24L01p11configRadioEbb+0x8>
 4fe:	1f 92       	push	r1
 500:	cd b7       	in	r28, 0x3d	; 61
 502:	de b7       	in	r29, 0x3e	; 62
@param bitNum is the bit to change, 0-7
@param setClear is the boolean value to set the bit 1 or 0
*/
unsigned char NRF24L01p::setBit(unsigned char byteIn, int bitNum, bool setClear)
{
	if(setClear == 1)
 504:	66 23       	and	r22, r22
 506:	11 f0       	breq	.+4      	; 0x50c <_ZN9NRF24L01p11configRadioEbb+0x16>
		byteIn |= (1<<bitNum);
 508:	2f e0       	ldi	r18, 0x0F	; 15
 50a:	01 c0       	rjmp	.+2      	; 0x50e <_ZN9NRF24L01p11configRadioEbb+0x18>
	else
		byteIn &= ~(1<<bitNum);
 50c:	2e e0       	ldi	r18, 0x0E	; 14
@param bitNum is the bit to change, 0-7
@param setClear is the boolean value to set the bit 1 or 0
*/
unsigned char NRF24L01p::setBit(unsigned char byteIn, int bitNum, bool setClear)
{
	if(setClear == 1)
 50e:	44 23       	and	r20, r20
 510:	11 f0       	breq	.+4      	; 0x516 <_ZN9NRF24L01p11configRadioEbb+0x20>
		byteIn |= (1<<bitNum);
 512:	22 60       	ori	r18, 0x02	; 2
 514:	01 c0       	rjmp	.+2      	; 0x518 <_ZN9NRF24L01p11configRadioEbb+0x22>
	else
		byteIn &= ~(1<<bitNum);
 516:	2d 7f       	andi	r18, 0xFD	; 253
	// Set PWRUP_PWRDOWN bit
	configByte = setBit(configByte,PWR_UP,PWRUP_PWRDOWN);
	
	// Write array
	unsigned char writeBytes [5];
	writeBytes[0]=configByte;
 518:	29 83       	std	Y+1, r18	; 0x01
	// Write to config register
	writeRegister(CONFIG, writeBytes, 1);
 51a:	21 e0       	ldi	r18, 0x01	; 1
 51c:	30 e0       	ldi	r19, 0x00	; 0
 51e:	ae 01       	movw	r20, r28
 520:	4f 5f       	subi	r20, 0xFF	; 255
 522:	5f 4f       	sbci	r21, 0xFF	; 255
 524:	60 e0       	ldi	r22, 0x00	; 0
 526:	0e 94 0d 02 	call	0x41a	; 0x41a <_ZN9NRF24L01p13writeRegisterEhPhi>
	
}
 52a:	0f 90       	pop	r0
 52c:	0f 90       	pop	r0
 52e:	0f 90       	pop	r0
 530:	0f 90       	pop	r0
 532:	0f 90       	pop	r0
 534:	df 91       	pop	r29
 536:	cf 91       	pop	r28
 538:	08 95       	ret

0000053a <_ZN9NRF24L01p6txModeEv>:
/* txMode Transmit Mode
Put radio into transmission mode
*/
void NRF24L01p::txMode(void)
{
	configRadio(0,1);
 53a:	41 e0       	ldi	r20, 0x01	; 1
 53c:	60 e0       	ldi	r22, 0x00	; 0
 53e:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <_ZN9NRF24L01p11configRadioEbb>
	// CE is held LOW unless a packet is being actively transmitted, In which case it is toggled high for >10us
	//digitalWrite(ce_pin, LOW);
	SPI_CE_PORT &= ~(1 << SPI_CE);                      /* Write CE pin low */
 542:	29 98       	cbi	0x05, 1	; 5
 544:	08 95       	ret

00000546 <_ZN9NRF24L01p5rModeEv>:
/* rMode Receive Mode
Put radio into receiving mode
*/
void NRF24L01p::rMode(void)
{
	configRadio(1,1);
 546:	41 e0       	ldi	r20, 0x01	; 1
 548:	61 e0       	ldi	r22, 0x01	; 1
 54a:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <_ZN9NRF24L01p11configRadioEbb>
	// CE HIGH monitors air and receives packets while in receive mode
	//digitalWrite(ce_pin, HIGH);
	SPI_CE_PORT |= (1 << SPI_CE);                       /* Write CE pin HIGH */
 54e:	29 9a       	sbi	0x05, 1	; 5
 550:	08 95       	ret

00000552 <_ZN9NRF24L01p6txDataEPhi>:
Transmit data
@param DATA is the data to transmit
@param BYTE_NUM is the number of bytes to transmit 1-5
*/
void NRF24L01p::txData(unsigned char DATA [], int BYTE_NUM)
{
 552:	ef 92       	push	r14
 554:	ff 92       	push	r15
 556:	0f 93       	push	r16
 558:	1f 93       	push	r17
 55a:	cf 93       	push	r28
 55c:	df 93       	push	r29
 55e:	7b 01       	movw	r14, r22
 560:	8a 01       	movw	r16, r20
	// Must start with CSN pin high, then bring CSN pin low for the transfer
	// Transmit the command byte
	// Bring CSN pin back to high
	
	//digitalWrite(csn_pin, LOW);
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CNS pin LOW */
 562:	2a 98       	cbi	0x05, 2	; 5
	SPI_tradeByte(W_TX_PAYLOAD); // This is the register that is being written to
 564:	80 ea       	ldi	r24, 0xA0	; 160
 566:	0e 94 50 03 	call	0x6a0	; 0x6a0 <_Z13SPI_tradeByteh>
	int ind=0;
	//Serial.println("DATA"); //DEBUG
	while (ind < BYTE_NUM)
 56a:	10 16       	cp	r1, r16
 56c:	11 06       	cpc	r1, r17
 56e:	4c f4       	brge	.+18     	; 0x582 <_ZN9NRF24L01p6txDataEPhi+0x30>
 570:	e7 01       	movw	r28, r14
 572:	0e 0d       	add	r16, r14
 574:	1f 1d       	adc	r17, r15
		//Serial.print("Element ");
		//Serial.print(ind);
		//Serial.print(": ");
		//Serial.println(DATA[ind]);
		
		SPI_tradeByte(DATA[ind]);
 576:	89 91       	ld	r24, Y+
 578:	0e 94 50 03 	call	0x6a0	; 0x6a0 <_Z13SPI_tradeByteh>
	//digitalWrite(csn_pin, LOW);
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CNS pin LOW */
	SPI_tradeByte(W_TX_PAYLOAD); // This is the register that is being written to
	int ind=0;
	//Serial.println("DATA"); //DEBUG
	while (ind < BYTE_NUM)
 57c:	c0 17       	cp	r28, r16
 57e:	d1 07       	cpc	r29, r17
 580:	d1 f7       	brne	.-12     	; 0x576 <_ZN9NRF24L01p6txDataEPhi+0x24>
		
		SPI_tradeByte(DATA[ind]);
		ind = ind+1;
	}
	//digitalWrite(csn_pin, HIGH);
	SPI_CSN_PORT |= (1 << SPI_CSN);                       /* Write CSN pin HIGH */
 582:	2a 9a       	sbi	0x05, 2	; 5
	
	// When sending packets, the CE pin (which is normally held low in TX operation) is set to high for a minimum of 10us to send the packet.
	//digitalWrite(ce_pin, HIGH);
	SPI_CE_PORT |= (1 << SPI_CE);                          /* Write CE pin HIGH */
 584:	29 9a       	sbi	0x05, 1	; 5
 586:	8f e1       	ldi	r24, 0x1F	; 31
 588:	9e e4       	ldi	r25, 0x4E	; 78
 58a:	01 97       	sbiw	r24, 0x01	; 1
 58c:	f1 f7       	brne	.-4      	; 0x58a <_ZN9NRF24L01p6txDataEPhi+0x38>
 58e:	00 c0       	rjmp	.+0      	; 0x590 <_ZN9NRF24L01p6txDataEPhi+0x3e>
 590:	00 00       	nop
	_delay_ms(10); 
	printString("Data sent from myRadio.txData\r\n");
 592:	88 e9       	ldi	r24, 0x98	; 152
 594:	92 e0       	ldi	r25, 0x02	; 2
 596:	0e 94 6e 03 	call	0x6dc	; 0x6dc <_Z11printStringPKc>
	//digitalWrite(ce_pin, LOW);
	SPI_CE_PORT &= ~(1 << SPI_CE);                         /* Write CE pin low */
 59a:	29 98       	cbi	0x05, 1	; 5
	three levels deep. This means that you can load up to three packets into the 24L01’s TX
	FIFO before you do the CE toggle to send them on their way.
	*/
	
	
}
 59c:	df 91       	pop	r29
 59e:	cf 91       	pop	r28
 5a0:	1f 91       	pop	r17
 5a2:	0f 91       	pop	r16
 5a4:	ff 90       	pop	r15
 5a6:	ef 90       	pop	r14
 5a8:	08 95       	ret

000005aa <_ZN9NRF24L01p5rDataEi>:
Receive data
@param BYTE_NUM is the number of bytes to receive 1-5 (Why 1-5? is this true? test if this can be larger)
register values are read into NRF24L01Class.register_value array
*/
unsigned char * NRF24L01p::rData(int byteNum)
{
 5aa:	cf 92       	push	r12
 5ac:	df 92       	push	r13
 5ae:	ef 92       	push	r14
 5b0:	ff 92       	push	r15
 5b2:	0f 93       	push	r16
 5b4:	1f 93       	push	r17
 5b6:	cf 93       	push	r28
 5b8:	df 93       	push	r29
 5ba:	6c 01       	movw	r12, r24
 5bc:	7b 01       	movw	r14, r22

	// Bring CE low to disable the receiver
	//digitalWrite(ce_pin, LOW);
	SPI_CE_PORT &= ~(1 << SPI_CE);                         /* Write CE pin low */
 5be:	29 98       	cbi	0x05, 1	; 5
	// Execute R_RX_PAYLOAD operation
	// First the command byte (0x61, R_RX_PAYLOAD) is sent and then the payload.
	// The number of payload bytes sent must match the payload length of the receiver you are sending the payload to
	
	//digitalWrite(csn_pin, LOW);
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CNS pin LOW */
 5c0:	2a 98       	cbi	0x05, 2	; 5
	
	SPI_tradeByte(R_RX_PAYLOAD); // This is the register that is being read from
 5c2:	81 e6       	ldi	r24, 0x61	; 97
 5c4:	0e 94 50 03 	call	0x6a0	; 0x6a0 <_Z13SPI_tradeByteh>
	int ind = 0;
	
	while (ind <= byteNum)
 5c8:	ff 20       	and	r15, r15
 5ca:	84 f0       	brlt	.+32     	; 0x5ec <_ZN9NRF24L01p5rDataEi+0x42>
 5cc:	86 01       	movw	r16, r12
 5ce:	02 5f       	subi	r16, 0xF2	; 242
 5d0:	1f 4f       	sbci	r17, 0xFF	; 255
	
	//digitalWrite(csn_pin, LOW);
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CNS pin LOW */
	
	SPI_tradeByte(R_RX_PAYLOAD); // This is the register that is being read from
	int ind = 0;
 5d2:	c0 e0       	ldi	r28, 0x00	; 0
 5d4:	d0 e0       	ldi	r29, 0x00	; 0
	
	while (ind <= byteNum)
	{
		SPI_tradeByte(0x00); // First byte returned is the status, subsequent bytes are from register
 5d6:	80 e0       	ldi	r24, 0x00	; 0
 5d8:	0e 94 50 03 	call	0x6a0	; 0x6a0 <_Z13SPI_tradeByteh>
		register_value[ind] = SPDR;
 5dc:	8e b5       	in	r24, 0x2e	; 46
 5de:	f8 01       	movw	r30, r16
 5e0:	81 93       	st	Z+, r24
 5e2:	8f 01       	movw	r16, r30
		//register_value[ind] = SPI_tradeByte(0x00); // First byte returned is the status, subsequent bytes are from register
		//Serial.print("Register byte ");
		//Serial.print(ind);
		//Serial.print(" value = ");
		//Serial.println(register_value[ind]);
		ind = ind+1;
 5e4:	21 96       	adiw	r28, 0x01	; 1
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CNS pin LOW */
	
	SPI_tradeByte(R_RX_PAYLOAD); // This is the register that is being read from
	int ind = 0;
	
	while (ind <= byteNum)
 5e6:	ec 16       	cp	r14, r28
 5e8:	fd 06       	cpc	r15, r29
 5ea:	ac f7       	brge	.-22     	; 0x5d6 <_ZN9NRF24L01p5rDataEi+0x2c>
		//Serial.println(register_value[ind]);
		ind = ind+1;
	}
	
	//digitalWrite(csn_pin, HIGH);
	SPI_CSN_PORT |= (1 << SPI_CSN);                       /* Write CSN pin HIGH */
 5ec:	2a 9a       	sbi	0x05, 2	; 5

	// Bring CE high to re-enable the receiver
	//digitalWrite(ce_pin, HIGH);
	SPI_CE_PORT |= (1 << SPI_CE);                          /* Write CE pin HIGH */
 5ee:	29 9a       	sbi	0x05, 1	; 5
	
	return register_value;
	
}
 5f0:	c6 01       	movw	r24, r12
 5f2:	0e 96       	adiw	r24, 0x0e	; 14
 5f4:	df 91       	pop	r29
 5f6:	cf 91       	pop	r28
 5f8:	1f 91       	pop	r17
 5fa:	0f 91       	pop	r16
 5fc:	ff 90       	pop	r15
 5fe:	ef 90       	pop	r14
 600:	df 90       	pop	r13
 602:	cf 90       	pop	r12
 604:	08 95       	ret

00000606 <_ZN9NRF24L01p7flushTXEv>:
{
	// Must start with CSN pin high, then bring CSN pin low for the transfer
	// Transmit the command byte
	// Bring CSN pin back to high
	//digitalWrite(csn_pin, LOW);
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CNS pin LOW */
 606:	2a 98       	cbi	0x05, 2	; 5
	SPI_tradeByte(FLUSH_TX); // This is the register that is being written to
 608:	81 ee       	ldi	r24, 0xE1	; 225
 60a:	0e 94 50 03 	call	0x6a0	; 0x6a0 <_Z13SPI_tradeByteh>
	//digitalWrite(csn_pin, HIGH);
	SPI_CSN_PORT |= (1 << SPI_CSN);                       /* Write CSN pin HIGH */
 60e:	2a 9a       	sbi	0x05, 2	; 5
 610:	08 95       	ret

00000612 <_ZN9NRF24L01p16clear_interruptsEv>:
	
}


void NRF24L01p::clear_interrupts(void)
{
 612:	0f 93       	push	r16
 614:	1f 93       	push	r17
 616:	cf 93       	push	r28
 618:	df 93       	push	r29
 61a:	1f 92       	push	r1
 61c:	cd b7       	in	r28, 0x3d	; 61
 61e:	de b7       	in	r29, 0x3e	; 62
 620:	8c 01       	movw	r16, r24
	// Clear any interrupts
	unsigned char tmp_state [] = {1<<RX_DR};
 622:	80 e4       	ldi	r24, 0x40	; 64
 624:	89 83       	std	Y+1, r24	; 0x01
	writeRegister(STATUS, tmp_state, 1);
 626:	21 e0       	ldi	r18, 0x01	; 1
 628:	30 e0       	ldi	r19, 0x00	; 0
 62a:	ae 01       	movw	r20, r28
 62c:	4f 5f       	subi	r20, 0xFF	; 255
 62e:	5f 4f       	sbci	r21, 0xFF	; 255
 630:	67 e0       	ldi	r22, 0x07	; 7
 632:	c8 01       	movw	r24, r16
 634:	0e 94 0d 02 	call	0x41a	; 0x41a <_ZN9NRF24L01p13writeRegisterEhPhi>
	tmp_state [0] = 1<<TX_DS;
 638:	80 e2       	ldi	r24, 0x20	; 32
 63a:	89 83       	std	Y+1, r24	; 0x01
	writeRegister(STATUS, tmp_state, 1);
 63c:	21 e0       	ldi	r18, 0x01	; 1
 63e:	30 e0       	ldi	r19, 0x00	; 0
 640:	ae 01       	movw	r20, r28
 642:	4f 5f       	subi	r20, 0xFF	; 255
 644:	5f 4f       	sbci	r21, 0xFF	; 255
 646:	67 e0       	ldi	r22, 0x07	; 7
 648:	c8 01       	movw	r24, r16
 64a:	0e 94 0d 02 	call	0x41a	; 0x41a <_ZN9NRF24L01p13writeRegisterEhPhi>
	tmp_state [0] = 1<<MAX_RT;
 64e:	80 e1       	ldi	r24, 0x10	; 16
 650:	89 83       	std	Y+1, r24	; 0x01
	writeRegister(STATUS, tmp_state, 1);
 652:	21 e0       	ldi	r18, 0x01	; 1
 654:	30 e0       	ldi	r19, 0x00	; 0
 656:	ae 01       	movw	r20, r28
 658:	4f 5f       	subi	r20, 0xFF	; 255
 65a:	5f 4f       	sbci	r21, 0xFF	; 255
 65c:	67 e0       	ldi	r22, 0x07	; 7
 65e:	c8 01       	movw	r24, r16
 660:	0e 94 0d 02 	call	0x41a	; 0x41a <_ZN9NRF24L01p13writeRegisterEhPhi>
	// Flush the TX register
	flushTX();
 664:	c8 01       	movw	r24, r16
 666:	0e 94 03 03 	call	0x606	; 0x606 <_ZN9NRF24L01p7flushTXEv>
}
 66a:	0f 90       	pop	r0
 66c:	df 91       	pop	r29
 66e:	cf 91       	pop	r28
 670:	1f 91       	pop	r17
 672:	0f 91       	pop	r16
 674:	08 95       	ret

00000676 <_ZN9NRF24L01p7flushRXEv>:
{
	// Must start with CSN pin high, then bring CSN pin low for the transfer
	// Transmit the command byte
	// Bring CSN pin back to high
	//digitalWrite(csn_pin, LOW);
	SPI_CSN_PORT &= ~(1 << SPI_CSN);                      /* Write CNS pin LOW */
 676:	2a 98       	cbi	0x05, 2	; 5
	SPI_tradeByte(FLUSH_RX); // This is the register that is being written to
 678:	82 ee       	ldi	r24, 0xE2	; 226
 67a:	0e 94 50 03 	call	0x6a0	; 0x6a0 <_Z13SPI_tradeByteh>
	//digitalWrite(csn_pin, HIGH);
	SPI_CSN_PORT |= (1 << SPI_CSN);                       /* Write CSN pin HIGH */
 67e:	2a 9a       	sbi	0x05, 2	; 5
 680:	08 95       	ret

00000682 <_Z13initSPImasterv>:
bool LED_latch_FLAG = false; // 0-not latched, 1-latched


void initSPImaster(void) {
  // set pin modes
  SPI_SS_DDR  |= (1 << SPI_SS);                       /* set SS Output */
 682:	22 9a       	sbi	0x04, 2	; 4
  SPI_SS_PORT |= (1 << SPI_SS);       /* Start off not selected (high) */
 684:	2a 9a       	sbi	0x05, 2	; 5

  SPI_MOSI_DDR   |= (1 << SPI_MOSI);                 /* output on MOSI */
 686:	23 9a       	sbi	0x04, 3	; 4
  //SPI_MISO_DDR   &= ~ (1 << SPI_MISO);                /* input on MISO */
  SPI_MISO_PORT  |= (1 << SPI_MISO);                 /* pullup on MISO */
 688:	2c 9a       	sbi	0x05, 4	; 5
  SPI_SCK_DDR |= (1 << SPI_SCK);                      /* output on SCK */
 68a:	25 9a       	sbi	0x04, 5	; 4

  /* Don't have to set phase, polarity b/c
   * default works with 25LCxxx chips */
  SPCR |= (1 << SPR1);                /* div 16, safer for breadboards */
 68c:	8c b5       	in	r24, 0x2c	; 44
 68e:	82 60       	ori	r24, 0x02	; 2
 690:	8c bd       	out	0x2c, r24	; 44
  SPCR |= (1 << MSTR);                                  /* clockmaster */
 692:	8c b5       	in	r24, 0x2c	; 44
 694:	80 61       	ori	r24, 0x10	; 16
 696:	8c bd       	out	0x2c, r24	; 44
  SPCR |= (1 << SPE);                                        /* enable */
 698:	8c b5       	in	r24, 0x2c	; 44
 69a:	80 64       	ori	r24, 0x40	; 64
 69c:	8c bd       	out	0x2c, r24	; 44
 69e:	08 95       	ret

000006a0 <_Z13SPI_tradeByteh>:
}


void SPI_tradeByte(uint8_t tData) {
//uint8_t SPI_tradeByte(uint8_t tData) {
  SPDR = tData;                        /* set SPI Data Register to tData */
 6a0:	8e bd       	out	0x2e, r24	; 46
  loop_until_bit_is_set(SPSR, SPIF);                /* wait until done */
 6a2:	0d b4       	in	r0, 0x2d	; 45
 6a4:	07 fe       	sbrs	r0, 7
 6a6:	fd cf       	rjmp	.-6      	; 0x6a2 <_Z13SPI_tradeByteh+0x2>
                                /* SPDR now contains the received byte */
  //return SPDR;
}
 6a8:	08 95       	ret

000006aa <_Z9initUSARTv>:
#include <avr/io.h>
#include "USART.h"
#include <util/setbaud.h>

void initUSART(void) {                                /* requires BAUD */
  UBRR0H = UBRRH_VALUE;                        /* defined in setbaud.h */
 6aa:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = UBRRL_VALUE;
 6ae:	83 e3       	ldi	r24, 0x33	; 51
 6b0:	80 93 c4 00 	sts	0x00C4, r24
#if USE_2X
  UCSR0A |= (1 << U2X0);
#else
  UCSR0A &= ~(1 << U2X0);
 6b4:	e0 ec       	ldi	r30, 0xC0	; 192
 6b6:	f0 e0       	ldi	r31, 0x00	; 0
 6b8:	80 81       	ld	r24, Z
 6ba:	8d 7f       	andi	r24, 0xFD	; 253
 6bc:	80 83       	st	Z, r24
#endif
                                  /* Enable USART transmitter/receiver */
  UCSR0B = (1 << TXEN0) | (1 << RXEN0);
 6be:	88 e1       	ldi	r24, 0x18	; 24
 6c0:	80 93 c1 00 	sts	0x00C1, r24
  UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);   /* 8 data bits, 1 stop bit */
 6c4:	86 e0       	ldi	r24, 0x06	; 6
 6c6:	80 93 c2 00 	sts	0x00C2, r24
 6ca:	08 95       	ret

000006cc <_Z12transmitByteh>:
}


void transmitByte(uint8_t data) {
                                     /* Wait for empty transmit buffer */
  loop_until_bit_is_set(UCSR0A, UDRE0);
 6cc:	e0 ec       	ldi	r30, 0xC0	; 192
 6ce:	f0 e0       	ldi	r31, 0x00	; 0
 6d0:	90 81       	ld	r25, Z
 6d2:	95 ff       	sbrs	r25, 5
 6d4:	fd cf       	rjmp	.-6      	; 0x6d0 <_Z12transmitByteh+0x4>
  UDR0 = data;                                            /* send data */
 6d6:	80 93 c6 00 	sts	0x00C6, r24
 6da:	08 95       	ret

000006dc <_Z11printStringPKc>:
}


                       /* Here are a bunch of useful printing commands */

void printString(const char myString[]) {
 6dc:	1f 93       	push	r17
 6de:	cf 93       	push	r28
 6e0:	df 93       	push	r29
 6e2:	ec 01       	movw	r28, r24
  uint8_t i = 0;
  while (myString[i]) {
 6e4:	88 81       	ld	r24, Y
 6e6:	88 23       	and	r24, r24
 6e8:	51 f0       	breq	.+20     	; 0x6fe <_Z11printStringPKc+0x22>


                       /* Here are a bunch of useful printing commands */

void printString(const char myString[]) {
  uint8_t i = 0;
 6ea:	10 e0       	ldi	r17, 0x00	; 0
  while (myString[i]) {
    transmitByte(myString[i]);
 6ec:	0e 94 66 03 	call	0x6cc	; 0x6cc <_Z12transmitByteh>
    i++;
 6f0:	1f 5f       	subi	r17, 0xFF	; 255

                       /* Here are a bunch of useful printing commands */

void printString(const char myString[]) {
  uint8_t i = 0;
  while (myString[i]) {
 6f2:	fe 01       	movw	r30, r28
 6f4:	e1 0f       	add	r30, r17
 6f6:	f1 1d       	adc	r31, r1
 6f8:	80 81       	ld	r24, Z
 6fa:	81 11       	cpse	r24, r1
 6fc:	f7 cf       	rjmp	.-18     	; 0x6ec <_Z11printStringPKc+0x10>
    transmitByte(myString[i]);
    i++;
  }
}
 6fe:	df 91       	pop	r29
 700:	cf 91       	pop	r28
 702:	1f 91       	pop	r17
 704:	08 95       	ret

00000706 <_Z9printWordj>:
  transmitByte('0' + (byte / 100));                        /* Hundreds */
  transmitByte('0' + ((byte / 10) % 10));                      /* Tens */
  transmitByte('0' + (byte % 10));                             /* Ones */
}

void printWord(uint16_t word) {
 706:	0f 93       	push	r16
 708:	1f 93       	push	r17
 70a:	cf 93       	push	r28
 70c:	df 93       	push	r29
 70e:	ec 01       	movw	r28, r24
  transmitByte('0' + (word / 10000));                 /* Ten-thousands */
 710:	9c 01       	movw	r18, r24
 712:	32 95       	swap	r19
 714:	22 95       	swap	r18
 716:	2f 70       	andi	r18, 0x0F	; 15
 718:	23 27       	eor	r18, r19
 71a:	3f 70       	andi	r19, 0x0F	; 15
 71c:	23 27       	eor	r18, r19
 71e:	a7 e4       	ldi	r26, 0x47	; 71
 720:	b3 e0       	ldi	r27, 0x03	; 3
 722:	0e 94 51 04 	call	0x8a2	; 0x8a2 <__umulhisi3>
 726:	96 95       	lsr	r25
 728:	87 95       	ror	r24
 72a:	96 95       	lsr	r25
 72c:	87 95       	ror	r24
 72e:	96 95       	lsr	r25
 730:	87 95       	ror	r24
 732:	80 5d       	subi	r24, 0xD0	; 208
 734:	0e 94 66 03 	call	0x6cc	; 0x6cc <_Z12transmitByteh>
  transmitByte('0' + ((word / 1000) % 10));               /* Thousands */
 738:	9e 01       	movw	r18, r28
 73a:	36 95       	lsr	r19
 73c:	27 95       	ror	r18
 73e:	36 95       	lsr	r19
 740:	27 95       	ror	r18
 742:	36 95       	lsr	r19
 744:	27 95       	ror	r18
 746:	a5 ec       	ldi	r26, 0xC5	; 197
 748:	b0 e2       	ldi	r27, 0x20	; 32
 74a:	0e 94 51 04 	call	0x8a2	; 0x8a2 <__umulhisi3>
 74e:	ac 01       	movw	r20, r24
 750:	52 95       	swap	r21
 752:	42 95       	swap	r20
 754:	4f 70       	andi	r20, 0x0F	; 15
 756:	45 27       	eor	r20, r21
 758:	5f 70       	andi	r21, 0x0F	; 15
 75a:	45 27       	eor	r20, r21
 75c:	9a 01       	movw	r18, r20
 75e:	ad ec       	ldi	r26, 0xCD	; 205
 760:	bc ec       	ldi	r27, 0xCC	; 204
 762:	0e 94 51 04 	call	0x8a2	; 0x8a2 <__umulhisi3>
 766:	96 95       	lsr	r25
 768:	87 95       	ror	r24
 76a:	96 95       	lsr	r25
 76c:	87 95       	ror	r24
 76e:	96 95       	lsr	r25
 770:	87 95       	ror	r24
 772:	9c 01       	movw	r18, r24
 774:	22 0f       	add	r18, r18
 776:	33 1f       	adc	r19, r19
 778:	88 0f       	add	r24, r24
 77a:	99 1f       	adc	r25, r25
 77c:	88 0f       	add	r24, r24
 77e:	99 1f       	adc	r25, r25
 780:	88 0f       	add	r24, r24
 782:	99 1f       	adc	r25, r25
 784:	82 0f       	add	r24, r18
 786:	93 1f       	adc	r25, r19
 788:	9a 01       	movw	r18, r20
 78a:	28 1b       	sub	r18, r24
 78c:	39 0b       	sbc	r19, r25
 78e:	c9 01       	movw	r24, r18
 790:	80 5d       	subi	r24, 0xD0	; 208
 792:	0e 94 66 03 	call	0x6cc	; 0x6cc <_Z12transmitByteh>
  transmitByte('0' + ((word / 100) % 10));                 /* Hundreds */
 796:	9e 01       	movw	r18, r28
 798:	36 95       	lsr	r19
 79a:	27 95       	ror	r18
 79c:	36 95       	lsr	r19
 79e:	27 95       	ror	r18
 7a0:	ab e7       	ldi	r26, 0x7B	; 123
 7a2:	b4 e1       	ldi	r27, 0x14	; 20
 7a4:	0e 94 51 04 	call	0x8a2	; 0x8a2 <__umulhisi3>
 7a8:	ac 01       	movw	r20, r24
 7aa:	56 95       	lsr	r21
 7ac:	47 95       	ror	r20
 7ae:	9a 01       	movw	r18, r20
 7b0:	ad ec       	ldi	r26, 0xCD	; 205
 7b2:	bc ec       	ldi	r27, 0xCC	; 204
 7b4:	0e 94 51 04 	call	0x8a2	; 0x8a2 <__umulhisi3>
 7b8:	96 95       	lsr	r25
 7ba:	87 95       	ror	r24
 7bc:	96 95       	lsr	r25
 7be:	87 95       	ror	r24
 7c0:	96 95       	lsr	r25
 7c2:	87 95       	ror	r24
 7c4:	9c 01       	movw	r18, r24
 7c6:	22 0f       	add	r18, r18
 7c8:	33 1f       	adc	r19, r19
 7ca:	88 0f       	add	r24, r24
 7cc:	99 1f       	adc	r25, r25
 7ce:	88 0f       	add	r24, r24
 7d0:	99 1f       	adc	r25, r25
 7d2:	88 0f       	add	r24, r24
 7d4:	99 1f       	adc	r25, r25
 7d6:	82 0f       	add	r24, r18
 7d8:	93 1f       	adc	r25, r19
 7da:	9a 01       	movw	r18, r20
 7dc:	28 1b       	sub	r18, r24
 7de:	39 0b       	sbc	r19, r25
 7e0:	c9 01       	movw	r24, r18
 7e2:	80 5d       	subi	r24, 0xD0	; 208
 7e4:	0e 94 66 03 	call	0x6cc	; 0x6cc <_Z12transmitByteh>
  transmitByte('0' + ((word / 10) % 10));                      /* Tens */
 7e8:	9e 01       	movw	r18, r28
 7ea:	ad ec       	ldi	r26, 0xCD	; 205
 7ec:	bc ec       	ldi	r27, 0xCC	; 204
 7ee:	0e 94 51 04 	call	0x8a2	; 0x8a2 <__umulhisi3>
 7f2:	8c 01       	movw	r16, r24
 7f4:	16 95       	lsr	r17
 7f6:	07 95       	ror	r16
 7f8:	16 95       	lsr	r17
 7fa:	07 95       	ror	r16
 7fc:	16 95       	lsr	r17
 7fe:	07 95       	ror	r16
 800:	98 01       	movw	r18, r16
 802:	0e 94 51 04 	call	0x8a2	; 0x8a2 <__umulhisi3>
 806:	96 95       	lsr	r25
 808:	87 95       	ror	r24
 80a:	96 95       	lsr	r25
 80c:	87 95       	ror	r24
 80e:	96 95       	lsr	r25
 810:	87 95       	ror	r24
 812:	9c 01       	movw	r18, r24
 814:	22 0f       	add	r18, r18
 816:	33 1f       	adc	r19, r19
 818:	88 0f       	add	r24, r24
 81a:	99 1f       	adc	r25, r25
 81c:	88 0f       	add	r24, r24
 81e:	99 1f       	adc	r25, r25
 820:	88 0f       	add	r24, r24
 822:	99 1f       	adc	r25, r25
 824:	82 0f       	add	r24, r18
 826:	93 1f       	adc	r25, r19
 828:	98 01       	movw	r18, r16
 82a:	28 1b       	sub	r18, r24
 82c:	39 0b       	sbc	r19, r25
 82e:	c9 01       	movw	r24, r18
 830:	80 5d       	subi	r24, 0xD0	; 208
 832:	0e 94 66 03 	call	0x6cc	; 0x6cc <_Z12transmitByteh>
  transmitByte('0' + (word % 10));                             /* Ones */
 836:	c8 01       	movw	r24, r16
 838:	88 0f       	add	r24, r24
 83a:	99 1f       	adc	r25, r25
 83c:	00 0f       	add	r16, r16
 83e:	11 1f       	adc	r17, r17
 840:	00 0f       	add	r16, r16
 842:	11 1f       	adc	r17, r17
 844:	00 0f       	add	r16, r16
 846:	11 1f       	adc	r17, r17
 848:	08 0f       	add	r16, r24
 84a:	19 1f       	adc	r17, r25
 84c:	ce 01       	movw	r24, r28
 84e:	80 1b       	sub	r24, r16
 850:	91 0b       	sbc	r25, r17
 852:	80 5d       	subi	r24, 0xD0	; 208
 854:	0e 94 66 03 	call	0x6cc	; 0x6cc <_Z12transmitByteh>
}
 858:	df 91       	pop	r29
 85a:	cf 91       	pop	r28
 85c:	1f 91       	pop	r17
 85e:	0f 91       	pop	r16
 860:	08 95       	ret

00000862 <_Z15printBinaryByteh>:

void printBinaryByte(uint8_t byte) {
 862:	1f 93       	push	r17
 864:	cf 93       	push	r28
 866:	df 93       	push	r29
 868:	1f 92       	push	r1
 86a:	cd b7       	in	r28, 0x3d	; 61
 86c:	de b7       	in	r29, 0x3e	; 62
 86e:	89 83       	std	Y+1, r24	; 0x01
                       /* Prints out a byte as a series of 1's and 0's */
  uint8_t bit;
  for (bit = 7; bit < 255; bit--) {
 870:	17 e0       	ldi	r17, 0x07	; 7
    if (bit_is_set(byte, bit))
 872:	89 81       	ldd	r24, Y+1	; 0x01
 874:	90 e0       	ldi	r25, 0x00	; 0
 876:	01 2e       	mov	r0, r17
 878:	02 c0       	rjmp	.+4      	; 0x87e <_Z15printBinaryByteh+0x1c>
 87a:	95 95       	asr	r25
 87c:	87 95       	ror	r24
 87e:	0a 94       	dec	r0
 880:	e2 f7       	brpl	.-8      	; 0x87a <_Z15printBinaryByteh+0x18>
 882:	80 ff       	sbrs	r24, 0
 884:	04 c0       	rjmp	.+8      	; 0x88e <_Z15printBinaryByteh+0x2c>
      transmitByte('1');
 886:	81 e3       	ldi	r24, 0x31	; 49
 888:	0e 94 66 03 	call	0x6cc	; 0x6cc <_Z12transmitByteh>
 88c:	03 c0       	rjmp	.+6      	; 0x894 <_Z15printBinaryByteh+0x32>
    else
      transmitByte('0');
 88e:	80 e3       	ldi	r24, 0x30	; 48
 890:	0e 94 66 03 	call	0x6cc	; 0x6cc <_Z12transmitByteh>
}

void printBinaryByte(uint8_t byte) {
                       /* Prints out a byte as a series of 1's and 0's */
  uint8_t bit;
  for (bit = 7; bit < 255; bit--) {
 894:	11 50       	subi	r17, 0x01	; 1
 896:	68 f7       	brcc	.-38     	; 0x872 <_Z15printBinaryByteh+0x10>
    if (bit_is_set(byte, bit))
      transmitByte('1');
    else
      transmitByte('0');
  }
}
 898:	0f 90       	pop	r0
 89a:	df 91       	pop	r29
 89c:	cf 91       	pop	r28
 89e:	1f 91       	pop	r17
 8a0:	08 95       	ret

000008a2 <__umulhisi3>:
 8a2:	a2 9f       	mul	r26, r18
 8a4:	b0 01       	movw	r22, r0
 8a6:	b3 9f       	mul	r27, r19
 8a8:	c0 01       	movw	r24, r0
 8aa:	a3 9f       	mul	r26, r19
 8ac:	70 0d       	add	r23, r0
 8ae:	81 1d       	adc	r24, r1
 8b0:	11 24       	eor	r1, r1
 8b2:	91 1d       	adc	r25, r1
 8b4:	b2 9f       	mul	r27, r18
 8b6:	70 0d       	add	r23, r0
 8b8:	81 1d       	adc	r24, r1
 8ba:	11 24       	eor	r1, r1
 8bc:	91 1d       	adc	r25, r1
 8be:	08 95       	ret

000008c0 <__tablejump2__>:
 8c0:	ee 0f       	add	r30, r30
 8c2:	ff 1f       	adc	r31, r31

000008c4 <__tablejump__>:
 8c4:	05 90       	lpm	r0, Z+
 8c6:	f4 91       	lpm	r31, Z
 8c8:	e0 2d       	mov	r30, r0
 8ca:	09 94       	ijmp

000008cc <_exit>:
 8cc:	f8 94       	cli

000008ce <__stop_program>:
 8ce:	ff cf       	rjmp	.-2      	; 0x8ce <__stop_program>
